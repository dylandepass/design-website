const t = window.ShadowRoot && (void 0 === window.ShadyCSS || window.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, s = Symbol(), i = new Map; class e { constructor(t, e) { if (this._$cssResult$ = !0, e !== s) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead."); this.cssText = t } get styleSheet() { let e = i.get(this.cssText); return t && void 0 === e && (i.set(this.cssText, e = new CSSStyleSheet), e.replaceSync(this.cssText)), e } toString() { return this.cssText } } const n = t => new e("string" == typeof t ? t : t + "", s), r = (t, ...i) => { const n = 1 === t.length ? t[0] : i.reduce((e, s, i) => e + (t => { if (!0 === t._$cssResult$) return t.cssText; if ("number" == typeof t) return t; throw Error("Value passed to 'css' function must be a 'css' function result: " + t + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.") })(s) + t[i + 1], t[0]); return new e(n, s) }, o = (e, s) => { t ? e.adoptedStyleSheets = s.map(t => t instanceof CSSStyleSheet ? t : t.styleSheet) : s.forEach(t => { const s = document.createElement("style"), i = window.litNonce; void 0 !== i && s.setAttribute("nonce", i), s.textContent = t.cssText, e.appendChild(s) }) }, l = t ? t => t : t => t instanceof CSSStyleSheet ? (t => { let e = ""; for (const s of t.cssRules) e += s.cssText; return n(e) })(t) : t; var h; const a = window.trustedTypes, u = a ? a.emptyScript : "", c = window.reactiveElementPolyfillSupport, d = { toAttribute(t, e) { switch (e) { case Boolean: t = t ? u : null; break; case Object: case Array: t = null == t ? t : JSON.stringify(t) }return t }, fromAttribute(t, e) { let s = t; switch (e) { case Boolean: s = null !== t; break; case Number: s = null === t ? null : Number(t); break; case Object: case Array: try { s = JSON.parse(t) } catch (t) { s = null } }return s } }, v = (t, e) => e !== t && (e == e || t == t), f = { attribute: !0, type: String, converter: d, reflect: !1, hasChanged: v }; class p extends HTMLElement { constructor() { super(), this.t = new Map, this.isUpdatePending = !1, this.hasUpdated = !1, this.i = null, this.o() } static addInitializer(t) { var e; null !== (e = this.l) && void 0 !== e || (this.l = []), this.l.push(t) } static get observedAttributes() { this.finalize(); const t = []; return this.elementProperties.forEach((e, s) => { const i = this.u(s, e); void 0 !== i && (this.g.set(i, s), t.push(i)) }), t } static createProperty(t, e = f) { if (e.state && (e.attribute = !1), this.finalize(), this.elementProperties.set(t, e), !e.noAccessor && !this.prototype.hasOwnProperty(t)) { const s = "symbol" == typeof t ? Symbol() : "__" + t, i = this.getPropertyDescriptor(t, s, e); void 0 !== i && Object.defineProperty(this.prototype, t, i) } } static getPropertyDescriptor(t, e, s) { return { get() { return this[e] }, set(i) { const n = this[t]; this[e] = i, this.requestUpdate(t, n, s) }, configurable: !0, enumerable: !0 } } static getPropertyOptions(t) { return this.elementProperties.get(t) || f } static finalize() { if (this.hasOwnProperty("finalized")) return !1; this.finalized = !0; const t = Object.getPrototypeOf(this); if (t.finalize(), this.elementProperties = new Map(t.elementProperties), this.g = new Map, this.hasOwnProperty("properties")) { const t = this.properties, e = [...Object.getOwnPropertyNames(t), ...Object.getOwnPropertySymbols(t)]; for (const s of e) this.createProperty(s, t[s]) } return this.elementStyles = this.finalizeStyles(this.styles), !0 } static finalizeStyles(t) { const e = []; if (Array.isArray(t)) { const s = new Set(t.flat(1 / 0).reverse()); for (const t of s) e.unshift(l(t)) } else void 0 !== t && e.push(l(t)); return e } static u(t, e) { const s = e.attribute; return !1 === s ? void 0 : "string" == typeof s ? s : "string" == typeof t ? t.toLowerCase() : void 0 } o() { var t; this._ = new Promise(t => this.enableUpdating = t), this._$AL = new Map, this.U(), this.requestUpdate(), null === (t = this.constructor.l) || void 0 === t || t.forEach(t => t(this)) } addController(t) { var e, s; (null !== (e = this.M) && void 0 !== e ? e : this.M = []).push(t), void 0 !== this.renderRoot && this.isConnected && (null === (s = t.hostConnected) || void 0 === s || s.call(t)) } removeController(t) { var e; null === (e = this.M) || void 0 === e || e.splice(this.M.indexOf(t) >>> 0, 1) } U() { this.constructor.elementProperties.forEach((t, e) => { this.hasOwnProperty(e) && (this.t.set(e, this[e]), delete this[e]) }) } createRenderRoot() { var t; const e = null !== (t = this.shadowRoot) && void 0 !== t ? t : this.attachShadow(this.constructor.shadowRootOptions); return o(e, this.constructor.elementStyles), e } connectedCallback() { var t; void 0 === this.renderRoot && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), null === (t = this.M) || void 0 === t || t.forEach(t => { var e; return null === (e = t.hostConnected) || void 0 === e ? void 0 : e.call(t) }) } enableUpdating(t) { } disconnectedCallback() { var t; null === (t = this.M) || void 0 === t || t.forEach(t => { var e; return null === (e = t.hostDisconnected) || void 0 === e ? void 0 : e.call(t) }) } attributeChangedCallback(t, e, s) { this._$AK(t, s) } q(t, e, s = f) { var i, n; const r = this.constructor.u(t, s); if (void 0 !== r && !0 === s.reflect) { const o = (null !== (n = null === (i = s.converter) || void 0 === i ? void 0 : i.toAttribute) && void 0 !== n ? n : d.toAttribute)(e, s.type); this.i = t, null == o ? this.removeAttribute(r) : this.setAttribute(r, o), this.i = null } } _$AK(t, e) { var s, i, n; const r = this.constructor, o = r.g.get(t); if (void 0 !== o && this.i !== o) { const t = r.getPropertyOptions(o), l = t.converter, a = null !== (n = null !== (i = null === (s = l) || void 0 === s ? void 0 : s.fromAttribute) && void 0 !== i ? i : "function" == typeof l ? l : null) && void 0 !== n ? n : d.fromAttribute; this.i = o, this[o] = a(e, t.type), this.i = null } } requestUpdate(t, e, s) { let i = !0; void 0 !== t && (((s = s || this.constructor.getPropertyOptions(t)).hasChanged || v)(this[t], e) ? (this._$AL.has(t) || this._$AL.set(t, e), !0 === s.reflect && this.i !== t && (void 0 === this.J && (this.J = new Map), this.J.set(t, s))) : i = !1), !this.isUpdatePending && i && (this._ = this.K()) } async K() { this.isUpdatePending = !0; try { await this._ } catch (t) { Promise.reject(t) } const t = this.scheduleUpdate(); return null != t && await t, !this.isUpdatePending } scheduleUpdate() { return this.performUpdate() } performUpdate() { var t; if (!this.isUpdatePending) return; this.hasUpdated, this.t && (this.t.forEach((t, e) => this[e] = t), this.t = void 0); let e = !1; const s = this._$AL; try { (e = this.shouldUpdate(s)) ? (this.willUpdate(s), null === (t = this.M) || void 0 === t || t.forEach(t => { var e; return null === (e = t.hostUpdate) || void 0 === e ? void 0 : e.call(t) }), this.update(s)) : this.G() } catch (t) { throw e = !1, this.G(), t } e && this._$AE(s) } willUpdate(t) { } _$AE(t) { var e; null === (e = this.M) || void 0 === e || e.forEach(t => { var e; return null === (e = t.hostUpdated) || void 0 === e ? void 0 : e.call(t) }), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t) } G() { this._$AL = new Map, this.isUpdatePending = !1 } get updateComplete() { return this.getUpdateComplete() } getUpdateComplete() { return this._ } shouldUpdate(t) { return !0 } update(t) { void 0 !== this.J && (this.J.forEach((t, e) => this.q(e, this[e], t)), this.J = void 0), this.G() } updated(t) { } firstUpdated(t) { } } var y; p.finalized = !0, p.elementProperties = new Map, p.elementStyles = [], p.shadowRootOptions = { mode: "open" }, null == c || c({ ReactiveElement: p }), (null !== (h = globalThis.reactiveElementVersions) && void 0 !== h ? h : globalThis.reactiveElementVersions = []).push("1.3.1"); const w = globalThis.trustedTypes, g = w ? w.createPolicy("lit-html", { createHTML: t => t }) : void 0, b = `lit$${(Math.random() + "").slice(9)}$`, m = "?" + b, $ = `<${m}>`, S = document, A = (t = "") => S.createComment(t), E = t => null === t || "object" != typeof t && "function" != typeof t, T = Array.isArray, _ = t => { var e; return T(t) || "function" == typeof (null === (e = t) || void 0 === e ? void 0 : e[Symbol.iterator]) }, C = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, x = /-->/g, M = />/g, U = />|[ 	\n\r](?:([^\s"'>=/]+)([ 	\n\r]*=[ 	\n\r]*(?:[^ 	\n\r"'`<>=]|("|')|))|$)/g, k = /'/g, R = /"/g, L = /^(?:script|style|textarea|title)$/i, O = t => (e, ...s) => ({ _$litType$: t, strings: e, values: s }), P = O(1), j = O(2), D = Symbol.for("lit-noChange"), N = Symbol.for("lit-nothing"), V = new WeakMap, H = (t, e, s) => { var i, n; const r = null !== (i = null == s ? void 0 : s.renderBefore) && void 0 !== i ? i : e; let o = r._$litPart$; if (void 0 === o) { const t = null !== (n = null == s ? void 0 : s.renderBefore) && void 0 !== n ? n : null; r._$litPart$ = o = new Z(e.insertBefore(A(), t), t, void 0, null != s ? s : {}) } return o._$AI(t), o }, I = S.createTreeWalker(S, 129, null, !1), z = (t, e) => { const s = t.length - 1, i = []; let n, r = 2 === e ? "<svg>" : "", o = C; for (let e = 0; e < s; e++) { const s = t[e]; let l, a, h = -1, c = 0; for (; c < s.length && (o.lastIndex = c, null !== (a = o.exec(s)));)c = o.lastIndex, o === C ? "!--" === a[1] ? o = x : void 0 !== a[1] ? o = M : void 0 !== a[2] ? (L.test(a[2]) && (n = RegExp("</" + a[2], "g")), o = U) : void 0 !== a[3] && (o = U) : o === U ? ">" === a[0] ? (o = null != n ? n : C, h = -1) : void 0 === a[1] ? h = -2 : (h = o.lastIndex - a[2].length, l = a[1], o = void 0 === a[3] ? U : '"' === a[3] ? R : k) : o === R || o === k ? o = U : o === x || o === M ? o = C : (o = U, n = void 0); const d = o === U && t[e + 1].startsWith("/>") ? " " : ""; r += o === C ? s + $ : h >= 0 ? (i.push(l), s.slice(0, h) + "$lit$" + s.slice(h) + b + d) : s + b + (-2 === h ? (i.push(void 0), e) : d) } const l = r + (t[s] || "<?>") + (2 === e ? "</svg>" : ""); if (!Array.isArray(t) || !t.hasOwnProperty("raw")) throw Error("invalid template strings array"); return [void 0 !== g ? g.createHTML(l) : l, i] }; class B { constructor({ strings: t, _$litType$: e }, s) { let i; this.parts = []; let n = 0, r = 0; const o = t.length - 1, l = this.parts, [a, h] = z(t, e); if (this.el = B.createElement(a, s), I.currentNode = this.el.content, 2 === e) { const t = this.el.content, e = t.firstChild; e.remove(), t.append(...e.childNodes) } for (; null !== (i = I.nextNode()) && l.length < o;) { if (1 === i.nodeType) { if (i.hasAttributes()) { const t = []; for (const e of i.getAttributeNames()) if (e.endsWith("$lit$") || e.startsWith(b)) { const s = h[r++]; if (t.push(e), void 0 !== s) { const t = i.getAttribute(s.toLowerCase() + "$lit$").split(b), e = /([.?@])?(.*)/.exec(s); l.push({ type: 1, index: n, name: e[2], strings: t, ctor: "." === e[1] ? q : "?" === e[1] ? F : "@" === e[1] ? Y : K }) } else l.push({ type: 6, index: n }) } for (const e of t) i.removeAttribute(e) } if (L.test(i.tagName)) { const t = i.textContent.split(b), e = t.length - 1; if (e > 0) { i.textContent = w ? w.emptyScript : ""; for (let s = 0; s < e; s++)i.append(t[s], A()), I.nextNode(), l.push({ type: 2, index: ++n }); i.append(t[e], A()) } } } else if (8 === i.nodeType) if (i.data === m) l.push({ type: 2, index: n }); else { let t = -1; for (; -1 !== (t = i.data.indexOf(b, t + 1));)l.push({ type: 7, index: n }), t += b.length - 1 } n++ } } static createElement(t, e) { const s = S.createElement("template"); return s.innerHTML = t, s } } function G(t, e, s = t, i) { var n, r, o, l; if (e === D) return e; let a = void 0 !== i ? null === (n = s.X) || void 0 === n ? void 0 : n[i] : s.Y; const h = E(e) ? void 0 : e._$litDirective$; return (null == a ? void 0 : a.constructor) !== h && (null === (r = null == a ? void 0 : a._$AO) || void 0 === r || r.call(a, !1), void 0 === h ? a = void 0 : (a = new h(t))._$AT(t, s, i), void 0 !== i ? (null !== (o = (l = s).X) && void 0 !== o ? o : l.X = [])[i] = a : s.Y = a), void 0 !== a && (e = G(t, a._$AS(t, e.values), a, i)), e } class W { constructor(t, e) { this.v = [], this._$AN = void 0, this._$AD = t, this._$AM = e } get parentNode() { return this._$AM.parentNode } get _$AU() { return this._$AM._$AU } p(t) { var e; const { el: { content: s }, parts: i } = this._$AD, n = (null !== (e = null == t ? void 0 : t.creationScope) && void 0 !== e ? e : S).importNode(s, !0); I.currentNode = n; let r = I.nextNode(), o = 0, l = 0, a = i[0]; for (; void 0 !== a;) { if (o === a.index) { let e; 2 === a.type ? e = new Z(r, r.nextSibling, this, t) : 1 === a.type ? e = new a.ctor(r, a.name, a.strings, this, t) : 6 === a.type && (e = new Q(r, this, t)), this.v.push(e), a = i[++l] } o !== (null == a ? void 0 : a.index) && (r = I.nextNode(), o++) } return n } m(t) { let e = 0; for (const s of this.v) void 0 !== s && (void 0 !== s.strings ? (s._$AI(t, s, e), e += s.strings.length - 2) : s._$AI(t[e])), e++ } } class Z { constructor(t, e, s, i) { var n; this.type = 2, this._$AH = N, this._$AN = void 0, this._$AA = t, this._$AB = e, this._$AM = s, this.options = i, this.tt = null === (n = null == i ? void 0 : i.isConnected) || void 0 === n || n } get _$AU() { var t, e; return null !== (e = null === (t = this._$AM) || void 0 === t ? void 0 : t._$AU) && void 0 !== e ? e : this.tt } get parentNode() { let t = this._$AA.parentNode; const e = this._$AM; return void 0 !== e && 11 === t.nodeType && (t = e.parentNode), t } get startNode() { return this._$AA } get endNode() { return this._$AB } _$AI(t, e = this) { t = G(this, t, e), E(t) ? t === N || null == t || "" === t ? (this._$AH !== N && this._$AR(), this._$AH = N) : t !== this._$AH && t !== D && this.$(t) : void 0 !== t._$litType$ ? this.T(t) : void 0 !== t.nodeType ? this.k(t) : _(t) ? this.S(t) : this.$(t) } A(t, e = this._$AB) { return this._$AA.parentNode.insertBefore(t, e) } k(t) { this._$AH !== t && (this._$AR(), this._$AH = this.A(t)) } $(t) { this._$AH !== N && E(this._$AH) ? this._$AA.nextSibling.data = t : this.k(S.createTextNode(t)), this._$AH = t } T(t) { var e; const { values: s, _$litType$: i } = t, n = "number" == typeof i ? this._$AC(t) : (void 0 === i.el && (i.el = B.createElement(i.h, this.options)), i); if ((null === (e = this._$AH) || void 0 === e ? void 0 : e._$AD) === n) this._$AH.m(s); else { const t = new W(n, this), e = t.p(this.options); t.m(s), this.k(e), this._$AH = t } } _$AC(t) { let e = V.get(t.strings); return void 0 === e && V.set(t.strings, e = new B(t)), e } S(t) { T(this._$AH) || (this._$AH = [], this._$AR()); const e = this._$AH; let s, i = 0; for (const n of t) i === e.length ? e.push(s = new Z(this.A(A()), this.A(A()), this, this.options)) : s = e[i], s._$AI(n), i++; i < e.length && (this._$AR(s && s._$AB.nextSibling, i), e.length = i) } _$AR(t = this._$AA.nextSibling, e) { var s; for (null === (s = this._$AP) || void 0 === s || s.call(this, !1, !0, e); t && t !== this._$AB;) { const e = t.nextSibling; t.remove(), t = e } } setConnected(t) { var e; void 0 === this._$AM && (this.tt = t, null === (e = this._$AP) || void 0 === e || e.call(this, t)) } } class K { constructor(t, e, s, i, n) { this.type = 1, this._$AH = N, this._$AN = void 0, this.element = t, this.name = e, this._$AM = i, this.options = n, s.length > 2 || "" !== s[0] || "" !== s[1] ? (this._$AH = Array(s.length - 1).fill(new String), this.strings = s) : this._$AH = N } get tagName() { return this.element.tagName } get _$AU() { return this._$AM._$AU } _$AI(t, e = this, s, i) { const n = this.strings; let r = !1; if (void 0 === n) t = G(this, t, e, 0), (r = !E(t) || t !== this._$AH && t !== D) && (this._$AH = t); else { const i = t; let o, l; for (t = n[0], o = 0; o < n.length - 1; o++)(l = G(this, i[s + o], e, o)) === D && (l = this._$AH[o]), r || (r = !E(l) || l !== this._$AH[o]), l === N ? t = N : t !== N && (t += (null != l ? l : "") + n[o + 1]), this._$AH[o] = l } r && !i && this.C(t) } C(t) { t === N ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, null != t ? t : "") } } class q extends K { constructor() { super(...arguments), this.type = 3 } C(t) { this.element[this.name] = t === N ? void 0 : t } } const J = w ? w.emptyScript : ""; class F extends K { constructor() { super(...arguments), this.type = 4 } C(t) { t && t !== N ? this.element.setAttribute(this.name, J) : this.element.removeAttribute(this.name) } } class Y extends K { constructor(t, e, s, i, n) { super(t, e, s, i, n), this.type = 5 } _$AI(t, e = this) { var s; if ((t = null !== (s = G(this, t, e, 0)) && void 0 !== s ? s : N) === D) return; const i = this._$AH, n = t === N && i !== N || t.capture !== i.capture || t.once !== i.once || t.passive !== i.passive, r = t !== N && (i === N || n); n && this.element.removeEventListener(this.name, this, i), r && this.element.addEventListener(this.name, this, t), this._$AH = t } handleEvent(t) { var e, s; "function" == typeof this._$AH ? this._$AH.call(null !== (s = null === (e = this.options) || void 0 === e ? void 0 : e.host) && void 0 !== s ? s : this.element, t) : this._$AH.handleEvent(t) } } class Q { constructor(t, e, s) { this.element = t, this.type = 6, this._$AN = void 0, this._$AM = e, this.options = s } get _$AU() { return this._$AM._$AU } _$AI(t) { G(this, t) } } const X = { P: "$lit$", L: b, V: m, I: 1, N: z, R: W, D: _, j: G, H: Z, O: K, F: F, B: Y, W: q, Z: Q }, tt = window.litHtmlPolyfillSupport; var st, it; null == tt || tt(B, Z), (null !== (y = globalThis.litHtmlVersions) && void 0 !== y ? y : globalThis.litHtmlVersions = []).push("2.2.1"); const et = p; class nt extends p { constructor() { super(...arguments), this.renderOptions = { host: this }, this.it = void 0 } createRenderRoot() { var t, e; const s = super.createRenderRoot(); return null !== (t = (e = this.renderOptions).renderBefore) && void 0 !== t || (e.renderBefore = s.firstChild), s } update(t) { const e = this.render(); this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this.it = H(e, this.renderRoot, this.renderOptions) } connectedCallback() { var t; super.connectedCallback(), null === (t = this.it) || void 0 === t || t.setConnected(!0) } disconnectedCallback() { var t; super.disconnectedCallback(), null === (t = this.it) || void 0 === t || t.setConnected(!1) } render() { return D } } nt.finalized = !0, nt._$litElement$ = !0, null === (st = globalThis.litElementHydrateSupport) || void 0 === st || st.call(globalThis, { LitElement: nt }); const rt = globalThis.litElementPolyfillSupport; null == rt || rt({ LitElement: nt }); const ot = { _$AK: (t, e, s) => { t._$AK(e, s) }, _$AL: t => t._$AL }; (null !== (it = globalThis.litElementVersions) && void 0 !== it ? it : globalThis.litElementVersions = []).push("3.2.0"); const { H: lt } = X, ht = t => null === t || "object" != typeof t && "function" != typeof t, at = { HTML: 1, SVG: 2 }, ut = (t, e) => { var s, i; return void 0 === e ? void 0 !== (null === (s = t) || void 0 === s ? void 0 : s._$litType$) : (null === (i = t) || void 0 === i ? void 0 : i._$litType$) === e }, ct = t => { var e; return void 0 !== (null === (e = t) || void 0 === e ? void 0 : e._$litDirective$) }, dt = t => { var e; return null === (e = t) || void 0 === e ? void 0 : e._$litDirective$ }, vt = t => void 0 === t.strings, ft = () => document.createComment(""), pt = (t, e, s) => { var i; const n = t._$AA.parentNode, r = void 0 === e ? t._$AB : e._$AA; if (void 0 === s) { const e = n.insertBefore(ft(), r), i = n.insertBefore(ft(), r); s = new lt(e, i, t, t.options) } else { const e = s._$AB.nextSibling, o = s._$AM, l = o !== t; if (l) { let e; null === (i = s._$AQ) || void 0 === i || i.call(s, t), s._$AM = t, void 0 !== s._$AP && (e = t._$AU) !== o._$AU && s._$AP(e) } if (e !== r || l) { let t = s._$AA; for (; t !== e;) { const e = t.nextSibling; n.insertBefore(t, r), t = e } } } return s }, yt = (t, e, s = t) => (t._$AI(e, s), t), wt = {}, gt = (t, e = wt) => t._$AH = e, bt = t => t._$AH, mt = t => { var e; null === (e = t._$AP) || void 0 === e || e.call(t, !1, !0); let s = t._$AA; const i = t._$AB.nextSibling; for (; s !== i;) { const t = s.nextSibling; s.remove(), s = t } }, $t = t => { t._$AR() }, St = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 }, At = t => (...e) => ({ _$litDirective$: t, values: e }); class Et { constructor(t) { } get _$AU() { return this._$AM._$AU } _$AT(t, e, s) { this.yt = t, this._$AM = e, this.wt = s } _$AS(t, e) { return this.update(t, e) } update(t, e) { return this.render(...e) } } const Tt = (t, e) => { var s, i; const n = t._$AN; if (void 0 === n) return !1; for (const t of n) null === (i = (s = t)._$AO) || void 0 === i || i.call(s, e, !1), Tt(t, e); return !0 }, _t = t => { let e, s; do { if (void 0 === (e = t._$AM)) break; (s = e._$AN).delete(t), t = e } while (0 === (null == s ? void 0 : s.size)) }, Ct = t => { for (let e; e = t._$AM; t = e) { let s = e._$AN; if (void 0 === s) e._$AN = s = new Set; else if (s.has(t)) break; s.add(t), Ut(e) } }; function xt(t) { void 0 !== this._$AN ? (_t(this), this._$AM = t, Ct(this)) : this._$AM = t } function Mt(t, e = !1, s = 0) { const i = this._$AH, n = this._$AN; if (void 0 !== n && 0 !== n.size) if (e) if (Array.isArray(i)) for (let t = s; t < i.length; t++)Tt(i[t], !1), _t(i[t]); else null != i && (Tt(i, !1), _t(i)); else Tt(this, t) } const Ut = t => { var e, s, i, n; 2 == t.type && (null !== (e = (i = t)._$AP) && void 0 !== e || (i._$AP = Mt), null !== (s = (n = t)._$AQ) && void 0 !== s || (n._$AQ = xt)) }; class kt extends Et { constructor() { super(...arguments), this._$AN = void 0 } _$AT(t, e, s) { super._$AT(t, e, s), Ct(this), this.isConnected = t._$AU } _$AO(t, e = !0) { var s, i; t !== this.isConnected && (this.isConnected = t, t ? null === (s = this.reconnected) || void 0 === s || s.call(this) : null === (i = this.disconnected) || void 0 === i || i.call(this)), e && (Tt(this, t), _t(this)) } setValue(t) { if (vt(this.yt)) this.yt._$AI(t, this); else { const e = [...this.yt._$AH]; e[this.wt] = t, this.yt._$AI(e, this, 0) } } disconnected() { } reconnected() { } } class Rt { constructor(t) { this.U = t } disconnect() { this.U = void 0 } reconnect(t) { this.U = t } deref() { return this.U } } class Lt { constructor() { this.Y = void 0, this.q = void 0 } get() { return this.Y } pause() { var t; null !== (t = this.Y) && void 0 !== t || (this.Y = new Promise(t => this.q = t)) } resume() { var t; null === (t = this.q) || void 0 === t || t.call(this), this.Y = this.q = void 0 } } class Ot extends kt { constructor() { super(...arguments), this.gt = new Rt(this), this.bt = new Lt } render(t, e) { return D } update(t, [e, s]) { if (this.isConnected || this.disconnected(), e === this.$t) return; this.$t = e; let i = 0; const { gt: n, bt: r } = this; return (async (t, e) => { for await (const s of t) if (!1 === await e(s)) return })(e, async t => { for (; r.get();)await r.get(); const o = n.deref(); if (void 0 !== o) { if (o.$t !== e) return !1; void 0 !== s && (t = s(t, i)), o.commitValue(t, i), i++ } return !0 }), D } commitValue(t, e) { this.setValue(t) } disconnected() { this.gt.disconnect(), this.bt.pause() } reconnected() { this.gt.reconnect(this), this.bt.resume() } } const Pt = At(Ot), jt = At(class extends Ot { constructor(t) { if (super(t), 2 !== t.type) throw Error("asyncAppend can only be used in child expressions") } update(t, e) { return this.St = t, super.update(t, e) } commitValue(t, e) { 0 === e && $t(this.St); const s = pt(this.St); yt(s, t) } }), Dt = At(class extends Et { constructor(t) { super(t), this.tt = new WeakMap } render(t) { return [t] } update(t, [e]) { if (ut(this.it) && (!ut(e) || this.it.strings !== e.strings)) { const e = bt(t).pop(); let s = this.tt.get(this.it.strings); if (void 0 === s) { const t = document.createDocumentFragment(); (s = H(N, t)).setConnected(!1), this.tt.set(this.it.strings, s) } gt(s, [e]), pt(s, void 0, e) } if (ut(e)) { if (!ut(this.it) || this.it.strings !== e.strings) { const s = this.tt.get(e.strings); if (void 0 !== s) { const e = bt(s).pop(); $t(t), pt(t, void 0, e), gt(t, [e]) } } this.it = e } else this.it = void 0; return this.render(e) } }), Nt = (t, e, s) => { for (const s of e) if (s[0] === t) return (0, s[1])(); return null == s ? void 0 : s() }, Vt = At(class extends Et { constructor(t) { var e; if (super(t), 1 !== t.type || "class" !== t.name || (null === (e = t.strings) || void 0 === e ? void 0 : e.length) > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.") } render(t) { return " " + Object.keys(t).filter(e => t[e]).join(" ") + " " } update(t, [e]) { var s, i; if (void 0 === this.et) { this.et = new Set, void 0 !== t.strings && (this.st = new Set(t.strings.join(" ").split(/\s/).filter(t => "" !== t))); for (const t in e) e[t] && !(null === (s = this.st) || void 0 === s ? void 0 : s.has(t)) && this.et.add(t); return this.render(e) } const n = t.element.classList; this.et.forEach(t => { t in e || (n.remove(t), this.et.delete(t)) }); for (const t in e) { const s = !!e[t]; s === this.et.has(t) || (null === (i = this.st) || void 0 === i ? void 0 : i.has(t)) || (s ? (n.add(t), this.et.add(t)) : (n.remove(t), this.et.delete(t))) } return D } }), Ht = {}, It = At(class extends Et { constructor() { super(...arguments), this.nt = Ht } render(t, e) { return e() } update(t, [e, s]) { if (Array.isArray(e)) { if (Array.isArray(this.nt) && this.nt.length === e.length && e.every((t, e) => t === this.nt[e])) return D } else if (this.nt === e) return D; return this.nt = Array.isArray(e) ? Array.from(e) : e, this.render(e, s) } }), zt = t => null != t ? t : N; function* Bt(t, e) { const s = "function" == typeof e; if (void 0 !== t) { let i = -1; for (const n of t) i > -1 && (yield s ? e(i) : e), i++, yield n } } const Gt = At(class extends Et { constructor() { super(...arguments), this.key = N } render(t, e) { return this.key = t, e } update(t, [e, s]) { return e !== this.key && (gt(t), this.key = e), s } }), Wt = At(class extends Et { constructor(t) { if (super(t), 3 !== t.type && 1 !== t.type && 4 !== t.type) throw Error("The `live` directive is not allowed on child or event bindings"); if (!vt(t)) throw Error("`live` bindings can only contain a single expression") } render(t) { return t } update(t, [e]) { if (e === D || e === N) return e; const s = t.element, i = t.name; if (3 === t.type) { if (e === s[i]) return D } else if (4 === t.type) { if (!!e === s.hasAttribute(i)) return D } else if (1 === t.type && s.getAttribute(i) === e + "") return D; return gt(t), e } }); function* Zt(t, e) { if (void 0 !== t) { let s = 0; for (const i of t) yield e(i, s++) } } function* Kt(t, e, s = 1) { const i = void 0 === e ? 0 : t; null != e || (e = t); for (let t = i; s > 0 ? t < e : e < t; t += s)yield t } const qt = () => new Jt; class Jt { } const Ft = new WeakMap, Yt = At(class extends kt { render(t) { return N } update(t, [e]) { var s; const i = e !== this.U; return i && void 0 !== this.U && this.ot(void 0), (i || this.rt !== this.lt) && (this.U = e, this.ht = null === (s = t.options) || void 0 === s ? void 0 : s.host, this.ot(this.lt = t.element)), N } ot(t) { "function" == typeof this.U ? (void 0 !== Ft.get(this.U) && this.U.call(this.ht, void 0), Ft.set(this.U, t), void 0 !== t && this.U.call(this.ht, t)) : this.U.value = t } get rt() { var t; return "function" == typeof this.U ? Ft.get(this.U) : null === (t = this.U) || void 0 === t ? void 0 : t.value } disconnected() { this.rt === this.lt && this.ot(void 0) } reconnected() { this.ot(this.lt) } }), Qt = (t, e, s) => { const i = new Map; for (let n = e; n <= s; n++)i.set(t[n], n); return i }, Xt = At(class extends Et { constructor(t) { if (super(t), 2 !== t.type) throw Error("repeat() can only be used in text expressions") } dt(t, e, s) { let i; void 0 === s ? s = e : void 0 !== e && (i = e); const n = [], r = []; let o = 0; for (const e of t) n[o] = i ? i(e, o) : o, r[o] = s(e, o), o++; return { values: r, keys: n } } render(t, e, s) { return this.dt(t, e, s).values } update(t, [e, s, i]) { var n; const r = bt(t), { values: o, keys: l } = this.dt(e, s, i); if (!Array.isArray(r)) return this.ut = l, o; const a = null !== (n = this.ut) && void 0 !== n ? n : this.ut = [], h = []; let c, d, u = 0, p = r.length - 1, v = 0, f = o.length - 1; for (; u <= p && v <= f;)if (null === r[u]) u++; else if (null === r[p]) p--; else if (a[u] === l[v]) h[v] = yt(r[u], o[v]), u++, v++; else if (a[p] === l[f]) h[f] = yt(r[p], o[f]), p--, f--; else if (a[u] === l[f]) h[f] = yt(r[u], o[f]), pt(t, h[f + 1], r[u]), u++, f--; else if (a[p] === l[v]) h[v] = yt(r[p], o[v]), pt(t, r[u], r[p]), p--, v++; else if (void 0 === c && (c = Qt(l, v, f), d = Qt(a, u, p)), c.has(a[u])) if (c.has(a[p])) { const e = d.get(l[v]), s = void 0 !== e ? r[e] : null; if (null === s) { const e = pt(t, r[u]); yt(e, o[v]), h[v] = e } else h[v] = yt(s, o[v]), pt(t, r[u], s), r[e] = null; v++ } else mt(r[p]), p--; else mt(r[u]), u++; for (; v <= f;) { const e = pt(t, h[f + 1]); yt(e, o[v]), h[v++] = e } for (; u <= p;) { const t = r[u++]; null !== t && mt(t) } return this.ut = l, gt(t, h), D } }), ts = At(class extends Et { constructor(t) { var e; if (super(t), 1 !== t.type || "style" !== t.name || (null === (e = t.strings) || void 0 === e ? void 0 : e.length) > 2) throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.") } render(t) { return Object.keys(t).reduce((e, s) => { const i = t[s]; return null == i ? e : e + `${s = s.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase()}:${i};` }, "") } update(t, [e]) { const { style: s } = t.element; if (void 0 === this.ct) { this.ct = new Set; for (const t in e) this.ct.add(t); return this.render(e) } this.ct.forEach(t => { null == e[t] && (this.ct.delete(t), t.includes("-") ? s.removeProperty(t) : s[t] = "") }); for (const t in e) { const i = e[t]; null != i && (this.ct.add(t), t.includes("-") ? s.setProperty(t, i) : s[t] = i) } return D } }), ss = At(class extends Et { constructor(t) { if (super(t), 2 !== t.type) throw Error("templateContent can only be used in child bindings") } render(t) { return this.vt === t ? D : (this.vt = t, document.importNode(t.content, !0)) } }); class is extends Et { constructor(t) { if (super(t), this.it = N, 2 !== t.type) throw Error(this.constructor.directiveName + "() can only be used in child bindings") } render(t) { if (t === N || null == t) return this.ft = void 0, this.it = t; if (t === D) return t; if ("string" != typeof t) throw Error(this.constructor.directiveName + "() called with a non-string value"); if (t === this.it) return this.ft; this.it = t; const e = [t]; return e.raw = e, this.ft = { _$litType$: this.constructor.resultType, strings: e, values: [] } } } is.directiveName = "unsafeHTML", is.resultType = 1; const es = At(is); class ns extends is { } ns.directiveName = "unsafeSVG", ns.resultType = 2; const rs = At(ns), os = t => !ht(t) && "function" == typeof t.then; class ls extends kt { constructor() { super(...arguments), this.At = 1073741823, this.Et = [], this.gt = new Rt(this), this.bt = new Lt } render(...t) { var e; return null !== (e = t.find(t => !os(t))) && void 0 !== e ? e : D } update(t, e) { const s = this.Et; let i = s.length; this.Et = e; const n = this.gt, r = this.bt; this.isConnected || this.disconnected(); for (let t = 0; t < e.length && !(t > this.At); t++) { const o = e[t]; if (!os(o)) return this.At = t, o; t < i && o === s[t] || (this.At = 1073741823, i = 0, Promise.resolve(o).then(async t => { for (; r.get();)await r.get(); const e = n.deref(); if (void 0 !== e) { const s = e.Et.indexOf(o); s > -1 && s < e.At && (e.At = s, e.setValue(t)) } })) } return D } disconnected() { this.gt.disconnect(), this.bt.pause() } reconnected() { this.gt.reconnect(this), this.bt.resume() } } const hs = At(ls); function as(t, e, s) { return t ? e() : null == s ? void 0 : s() } const us = t => ({ _$litStatic$: t }), cs = (t, ...e) => ({ _$litStatic$: e.reduce((e, s, i) => e + (t => { if (void 0 !== t._$litStatic$) return t._$litStatic$; throw Error(`Value passed to 'literal' function must be a 'literal' result: ${t}. Use 'unsafeStatic' to pass non-literal values, but\n            take care to ensure page security.`) })(s) + t[i + 1], t[0]) }), ds = new Map, vs = t => (e, ...s) => { var i; const n = s.length; let r, o; const l = [], a = []; let h, c = 0, d = !1; for (; c < n;) { for (h = e[c]; c < n && void 0 !== (r = null === (i = o = s[c]) || void 0 === i ? void 0 : i._$litStatic$);)h += r + e[++c], d = !0; a.push(o), l.push(h), c++ } if (c === n && l.push(e[n]), d) { const t = l.join("$$lit$$"); void 0 === (e = ds.get(t)) && (l.raw = l, ds.set(t, e = l)), s = a } return t(e, ...s) }, fs = vs(P), ps = vs(j); window.litDisableBundleWarning || console.warn("Lit has been loaded from a bundle that combines all core features into a single file. To reduce transfer size and parsing cost, consider using the `lit` npm package directly in your project."); export { kt as AsyncDirective, Ot as AsyncReplaceDirective, e as CSSResult, Et as Directive, nt as LitElement, St as PartType, p as ReactiveElement, at as TemplateResultType, is as UnsafeHTMLDirective, ls as UntilDirective, et as UpdatingElement, ot as _$LE, X as _$LH, o as adoptStyles, jt as asyncAppend, Pt as asyncReplace, Dt as cache, Nt as choose, Vt as classMap, $t as clearPart, qt as createRef, r as css, d as defaultConverter, At as directive, bt as getCommittedValue, l as getCompatibleStyle, dt as getDirectiveClass, It as guard, P as html, zt as ifDefined, pt as insertPart, ct as isDirectiveResult, ht as isPrimitive, vt as isSingleExpression, ut as isTemplateResult, Bt as join, Gt as keyed, cs as literal, Wt as live, Zt as map, D as noChange, v as notEqual, N as nothing, Kt as range, Yt as ref, mt as removePart, H as render, Xt as repeat, yt as setChildPartValue, gt as setCommittedValue, fs as staticHtml, ps as staticSvg, ts as styleMap, t as supportsAdoptingStyleSheets, j as svg, ss as templateContent, n as unsafeCSS, es as unsafeHTML, rs as unsafeSVG, us as unsafeStatic, hs as until, as as when, vs as withStatic };